---
import { t } from '../../lib/i18n';

const runtimeTabLabel = t('components.default_tab_title');
const runtimeChartSeriesLabel = t('components.chart_series_label');
const runtimeChartErrorLabel = t('components.chart_render_error');
const runtimeKaTeXErrorLabel = t('components.katex_render_error');
---

<script is:inline src="/blowfish-lib/packery/packery.pkgd.min.js"></script>
<script is:inline src="/blowfish-lib/mermaid/mermaid.min.js"></script>
<script is:inline src="/blowfish-lib/chart/chart.min.js"></script>
<link rel="stylesheet" href="/blowfish-lib/katex/katex.min.css" />
<script is:inline src="/blowfish-lib/katex/katex.min.js"></script>
<script is:inline src="/blowfish-lib/katex/auto-render.min.js"></script>
<script is:inline src="/blowfish-lib/typeit/typeit.umd.js"></script>
<script is:inline src="/blowfish-lib/lite-youtube-embed/lite-yt-embed.js"></script>

<script
  is:inline
  define:vars={{
    runtimeTabLabel,
    runtimeChartSeriesLabel,
    runtimeChartErrorLabel,
    runtimeKaTeXErrorLabel,
  }}
>
  const TAB_FALLBACK = runtimeTabLabel;
  const CHART_SERIES_LABEL = runtimeChartSeriesLabel;
  const CHART_ERROR_LABEL = runtimeChartErrorLabel;
  const KATEX_ERROR_LABEL = runtimeKaTeXErrorLabel;
  let katexRetryCount = 0;
  const TAB_BUTTON_BASE =
    'tab__button px-3 py-2 text-sm font-semibold border-b-2 border-transparent rounded-t-md hover:bg-neutral-200 dark:hover:bg-neutral-700';
  const TAB_BUTTON_ACTIVE = 'tab--active border-primary-500 dark:border-primary-400';

  const escapeHtml = (value) =>
    value
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;');

  const setBackgroundBlur = (targetId, scrollDivisor = 300, disableBlur = false, isMenuBlur = false) => {
    if (!targetId) return;
    const blurElement = document.getElementById(targetId);
    if (!blurElement) return;

    if (blurElement.__bfBlurHandler) {
      window.removeEventListener('scroll', blurElement.__bfBlurHandler);
    }

    if (disableBlur) {
      blurElement.setAttribute('aria-hidden', 'true');
      if (!isMenuBlur) {
        blurElement.style.display = 'none';
        blurElement.style.opacity = '0';
      } else {
        blurElement.style.display = '';
      }
    } else {
      blurElement.style.display = '';
      blurElement.removeAttribute('aria-hidden');
    }

    const updateBlur = () => {
      if (!disableBlur || isMenuBlur) {
        const scroll = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
        blurElement.style.opacity = String(scroll / scrollDivisor);
      }
    };

    blurElement.__bfBlurHandler = updateBlur;
    blurElement.setAttribute('role', 'presentation');
    blurElement.setAttribute('tabindex', '-1');
    window.addEventListener('scroll', updateBlur);
    updateBlur();
  };

  const initBackgroundBlur = () => {
    let settings = {};
    try {
      settings = JSON.parse(localStorage.getItem('a11ySettings') || '{}');
    } catch {}
    const disableBlur = Boolean(settings.disableBlur);

    document.querySelectorAll('script[data-blur-id]').forEach((script) => {
      const targetId = script.getAttribute('data-blur-id');
      const scrollDivisor = Number(script.getAttribute('data-scroll-divisor') || 300);
      const isMenuBlur = targetId === 'menu-blur';
      setBackgroundBlur(targetId, scrollDivisor, disableBlur, isMenuBlur);
    });
  };

  const runTabs = () => {
    document.querySelectorAll('.tab__container, .bf-tabs').forEach((container) => {
      const tabs = Array.from(container.querySelectorAll('.tab__panel, .bf-tab'));
      if (!tabs.length) return;

      let navHost = container.querySelector('.tab__nav');
      if (!navHost) {
        navHost = document.createElement('div');
        navHost.className = 'tab__nav';
        const navRow = document.createElement('div');
        navRow.className = 'flex flex-wrap gap-1';
        navHost.appendChild(navRow);
        container.prepend(navHost);
      }

      let nav = navHost.querySelector(':scope > div');
      if (!nav) {
        nav = document.createElement('div');
        nav.className = 'flex flex-wrap gap-1';
        navHost.appendChild(nav);
      }

      nav.innerHTML = '';

      const defaultTab =
        container.getAttribute('data-default-tab') || container.getAttribute('data-default');
      let activeName =
        tabs.find((tab) => tab.getAttribute('data-active') === 'true')?.getAttribute('data-tab-label') ||
        tabs.find((tab) => tab.getAttribute('data-active') === 'true')?.getAttribute('data-name');
      if (!activeName) {
        activeName =
          defaultTab ||
          tabs[0].getAttribute('data-tab-label') ||
          tabs[0].getAttribute('data-name') ||
          TAB_FALLBACK;
      }

      const activate = (name) => {
        tabs.forEach((tab) => {
          const tabName = tab.getAttribute('data-tab-label') || tab.getAttribute('data-name') || TAB_FALLBACK;
          const current = tabName === name;
          tab.classList.toggle('tab--active', current);
          tab.style.display = current ? 'block' : 'none';
          tab.setAttribute('data-active', current ? 'true' : 'false');
        });

        nav.querySelectorAll('button').forEach((btn) => {
          const selected = btn.getAttribute('data-name') === name;
          btn.setAttribute('aria-selected', selected ? 'true' : 'false');
          btn.className = `${TAB_BUTTON_BASE} ${selected ? TAB_BUTTON_ACTIVE : ''}`.trim();
        });
      };

      tabs.forEach((tab) => {
        const name = tab.getAttribute('data-tab-label') || tab.getAttribute('data-name') || TAB_FALLBACK;
        const icon = tab.getAttribute('data-tab-icon');
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = TAB_BUTTON_BASE;
        btn.setAttribute('data-name', name);
        btn.setAttribute('role', 'tab');
        btn.setAttribute('aria-selected', 'false');
        btn.innerHTML = icon
          ? `<span class="flex items-center gap-1"><span class="relative inline-block align-text-bottom icon"><img src="/blowfish-icons/${icon}.svg" alt="" class="h-[1em] w-[1em]" aria-hidden="true" /></span>${name}</span>`
          : `<span class="flex items-center gap-1">${name}</span>`;
        btn.addEventListener('click', () => activate(name));
        nav.appendChild(btn);
      });

      activate(activeName);
    });
  };

  const runGallery = () => {
    if (!window.Packery) return;
    document.querySelectorAll('.gallery, .bf-gallery').forEach((gallery) => {
      if (gallery.__bfPackery) return;
      gallery.__bfPackery = new window.Packery(gallery, {
        itemSelector: 'figure',
        percentPosition: true,
        gutter: 12
      });
    });
  };

  const runMermaid = async () => {
    if (!window.mermaid) return;
    if (!window.__bfMermaidReady) {
      window.mermaid.initialize({ startOnLoad: false, securityLevel: 'loose' });
      window.__bfMermaidReady = true;
    }

    const blocks = Array.from(document.querySelectorAll('.language-mermaid'));
    for (const block of blocks) {
      const parent = block.closest('.bf-mermaid');
      if (!parent || parent.getAttribute('data-rendered') === 'true') continue;
      const code = parent.getAttribute('data-graph') || block.textContent || '';
      parent.setAttribute('data-graph', code);
      const id = `bf-mermaid-${Math.random().toString(36).slice(2)}`;
      try {
        const rendered = await window.mermaid.render(id, code);
        parent.innerHTML = rendered.svg;
        parent.setAttribute('data-rendered', 'true');
      } catch {
        // keep original block if render fails
      }
    }
  };

  window.updateMermaidTheme = () => {
    document.querySelectorAll('.bf-mermaid[data-rendered="true"]').forEach((parent) => {
      const code = parent.getAttribute('data-graph');
      if (!code) return;
      parent.innerHTML = `<code class="language-mermaid">${escapeHtml(code)}</code>`;
      parent.setAttribute('data-rendered', 'false');
    });
    runMermaid();
  };

  window.setBackgroundBlur = setBackgroundBlur;

  const runKaTeX = () => {
    if (!window.katex || typeof window.katex.render !== 'function') {
      if (katexRetryCount < 20) {
        katexRetryCount += 1;
        window.setTimeout(runKaTeX, 100);
      }
      return;
    }

    document.querySelectorAll('[data-bf-katex]').forEach((el) => {
      if (el.getAttribute('data-rendered') === 'true') return;
      const equation = el.getAttribute('data-equation') || el.textContent || '';
      const displayMode = el.getAttribute('data-display') === 'true';
      if (!equation.trim()) return;

      try {
        window.katex.render(equation, el, {
          displayMode,
          throwOnError: false,
          strict: 'warn'
        });
        el.setAttribute('data-rendered', 'true');
      } catch {
        el.textContent = `${KATEX_ERROR_LABEL}: ${equation}`;
      }
    });
  };

  const getChartCtor = () => {
    if (typeof window.Chart === 'function') return window.Chart;
    if (window.Chart && typeof window.Chart.Chart === 'function') return window.Chart.Chart;
    return null;
  };

  const parseJson = (rawValue, fallback) => {
    if (!rawValue) return fallback;
    try {
      return JSON.parse(rawValue);
    } catch {
      return fallback;
    }
  };

  const parseChartLabels = (rawValue) => {
    const parsed = parseJson(rawValue, null);
    if (Array.isArray(parsed)) return parsed.map((value) => String(value));
    if (typeof rawValue === 'string' && rawValue.includes(',')) {
      return rawValue
        .split(',')
        .map((value) => value.trim())
        .filter(Boolean);
    }
    return [];
  };

  const parseChartData = (rawValue) => {
    const parsed = parseJson(rawValue, null);
    if (Array.isArray(parsed)) {
      return parsed
        .map((value) => Number(value))
        .filter((value) => Number.isFinite(value));
    }
    if (typeof rawValue === 'string' && rawValue.includes(',')) {
      return rawValue
        .split(',')
        .map((value) => Number(value.trim()))
        .filter((value) => Number.isFinite(value));
    }
    return [];
  };

  const setChartError = (el, details = '') => {
    const previousError = el.querySelector('[data-bf-chart-error]');
    if (previousError) previousError.remove();

    const message = document.createElement('p');
    message.setAttribute('data-bf-chart-error', 'true');
    message.className = 'mt-2 text-sm text-red-600 dark:text-red-400';
    message.textContent = details ? `${CHART_ERROR_LABEL} (${details})` : CHART_ERROR_LABEL;
    el.appendChild(message);
  };

  const runCharts = () => {
    const ChartCtor = getChartCtor();
    if (!ChartCtor) return;

    document.querySelectorAll('[data-bf-chart]').forEach((el) => {
      if (el.getAttribute('data-rendered') === 'true') return;

      const existingCanvas = el.querySelector('canvas');
      if (existingCanvas) existingCanvas.remove();
      const previousError = el.querySelector('[data-bf-chart-error]');
      if (previousError) previousError.remove();

      const configRaw = el.getAttribute('data-config');
      const canvas = document.createElement('canvas');
      canvas.className = 'block';
      canvas.style.width = '100%';
      canvas.style.height = '220px';
      el.appendChild(canvas);
      const context = canvas.getContext('2d');
      if (!context) {
        setChartError(el, 'canvas');
        return;
      }

      let rendered = false;

      if (configRaw) {
        try {
          const config = JSON.parse(configRaw);
          new ChartCtor(context, config);
          rendered = true;
        } catch {
          // fall back to data-* format if JSON parse fails
        }
      }

      if (!rendered) {
        const type = el.getAttribute('data-type') || 'bar';
        const labels = parseChartLabels(el.getAttribute('data-labels') || '[]');
        const data = parseChartData(el.getAttribute('data-data') || '[]');

        if (!labels.length || !data.length) {
          setChartError(el, 'data');
          return;
        }

        try {
          new ChartCtor(context, {
            type,
            data: {
              labels,
              datasets: [
                {
                  label: CHART_SERIES_LABEL,
                  data,
                  backgroundColor: 'rgba(14, 116, 144, 0.45)',
                  borderColor: 'rgba(14, 116, 144, 1)',
                  borderWidth: 2
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false
            }
          });
          rendered = true;
        } catch {
          setChartError(el);
          return;
        }
      }

      if (rendered) {
        el.setAttribute('data-rendered', 'true');
      } else {
        setChartError(el);
      }
    });
  };

  const runTypeIt = () => {
    if (!window.TypeIt) return;
    document.querySelectorAll('.bf-typeit').forEach((el) => {
      if (el.getAttribute('data-rendered') === 'true') return;
      const speed = Number(el.getAttribute('data-speed') || 75);
      const loop = el.getAttribute('data-loop') === 'true';
      const text = el.textContent || '';
      el.textContent = '';
      new window.TypeIt(el, {
        speed,
        loop,
        waitUntilVisible: true,
        strings: [text]
      }).go();
      el.setAttribute('data-rendered', 'true');
    });
  };

  const safeRun = (fn) => {
    try {
      const output = fn();
      if (output && typeof output.then === 'function') {
        output.catch(() => {});
      }
    } catch {
      // keep other runtime hooks running
    }
  };

  const runAll = () => {
    safeRun(runKaTeX);
    safeRun(initBackgroundBlur);
    safeRun(runTabs);
    safeRun(runGallery);
    safeRun(runMermaid);
    safeRun(runCharts);
    safeRun(runTypeIt);
  };

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', runAll);
  } else {
    runAll();
  }

  window.addEventListener('load', runAll);
  document.addEventListener('astro:page-load', runAll);
</script>
